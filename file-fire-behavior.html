<link rel="import" href="../polymerfire/firebase.html">
<script>
/** @polymerBehavior FileFire.FileFireBehavior */
FileFireBehavior = {
  properties: {
    /**
      * `appName` represents the name of the firebase-app that was instantiated
      */
    appName: {
        type: String,
    },
    /**
      * `storagePath` represents where the file should be saved, if the path doesnt exist it will be created
      */
    path: {
        type: String,
    },
    /**
      * `srcUrl` represents where to fetch a file from if it is not local
      */
    srcUrl: {
        type: String,
        observer: "_loadImage",
    },
    /**
      * `srcFile` represents the file blob stored in a variable
      */
    srcFile: {
        type: Boolean,
        value: false,
    },
    /**
      * `overwrite` represents if a file can be overwritten or not, when set to false the file name will be prefixed with the curent epoch
      */
    overWrite: {
        type: Boolean,
        value: false,
    },
    /**
      * `onlyImages` represents whether to accept only images
      */
    onlyImages: {
        type: Boolean,
        value: false
    },
    /**
      * `resizeHeight` represents the height to resize an image to, if no resize values provided, image swill be uploaded as is
      */
    resizeHeight:{
      type: Number
    },
    /**
      * `resizeWidth` represents the width to resize an image to, if no resize values provided, images will be uploaded as is
      */
    resizeWidth:{
      type: Number
    },
    /**
      * `maxScale` represents the integer of the max scale needed. Ex. Setting a max scale of 3 and scale steps of 1 will return 1x, 2x and 3x images of the resized dimension
      */
    maxScale:{
      type: Number,
      value: 1
    },
    /**
      * `scaleStep` represents the steps to take for each image resize. Ex. Setting a max scale of 2 and scale steps of 0.5 will return 1x, 1.5x and 2x images of the resized dimension
      */
    scaleStep:{
      type: Number,
      value: 1
    },
    /**
      * `maxDimension` represents the maximum width or height to be allowed for an image
      */
    maxDimension: {
        type: Number,
        value: 300
    },
    /**
      * `maxSize` represents the maximum size of a file to allow
      */
    maxSize: {
        type: Number,
        value: 0
    },
    /**
      * `progress` represents a percentage value for the file upload
      */
    progress: {
        type: Number,
        reflectToAttribute: true,
        notify: true,
    },
    /**
      * `placeholder` is a base64 string representing 10% resize of the specified resized image
      */
    placeholder: {
        type: String,
        reflectToAttribute: true,
        notify: true,
    },
    /**
      * `files` is an array of images that have been resized based on the desired inputs
      */
    files: {
      type: Array,
      reflectToAttribute: true,
      notify: true
    },
    /**
      * `downloadUrl` is the array to direct urls to the uploaded file
      */
    downloadUrl: {
      type: Array,
      reflectToAttribute: true,
      notify: true,
      value: []
    }
  },

  /**
    * Loads the image, adds it to a canvas then calls _resize with the canvas once it's ready
    */
  _loadImage: function(event){
    var externalLink = this.srcUrl;
    // If we're getting a remote file
    if(this.srcUrl != null){
      var str = this.srcUrl.split("/");
      if(str[2] == "pbs.twimg.com"){
        externalLink = this.srcUrl.replace("normal", "400x400");
      }
      // Get remote image
      fetch(externalLink).then(function(response){
        return response.blob();
      }).then(function(blob){
        // Create file from image
        type = blob.type;
        file = blob;
        // Detect file type and upload accordingly
        if(type.startsWith("image")){
          this._imageUpload(file);
        } else{
          this._fileUpload(file);
        }
      }.bind(this));
    }else {
      file = event.target.files[0];
      type = event.target.files[0].type;
      // console.log(type)
        if(type.startsWith("image")){
          this._imageUpload(file);
        } else{
          this._fileUpload(file);
        }
      }
  },

  /**
   * Uploads image files
   */
_imageUpload: function(file){
    // If we DO NOT need to resize the image do this....
    if(this.resizeWidth == null || this.resizeHeight == null){
      // console.log("Not resizing")
        this._uploadThis(file, this.path.substring(this.path.lastIndexOf('/')+1)).then(function(){
        this.fire("upload", {
          "placeholder": this.placeholder,
          "urls": this.downloadUrl
        });
      }.bind(this));
    } else {
      img = new Image();
      img.src = file;
      img.src = URL.createObjectURL(file);
      img.onload = function(){
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');
        canvas.width = img.width;
        canvas.height = img.height;
        context.drawImage(img, 0, 0, img.width, img.height);                
        var x = this._resize(canvas, img.width, img.height);
        x.then(function(){
          this.fire("upload", {
            "placeholder": this.placeholder,
            "urls": this.downloadUrl
          });
        }.bind(this));
      }.bind(this)
    }
  },

  /**
   * Uploads non image files
   */
  _fileUpload: function(file){
    // Progress isnt working tested with a large mp3 file
      this._uploadThis(file, this.path.substring(this.path.lastIndexOf('/')+1)).then(function(){
        // we could have standard base 64 placeholders for non image files
          this.fire("upload", {
            "placeholder": this.placeholder,
            "urls": this.downloadUrl
          });
    }.bind(this));
  },

  /**
   * Resizes the image and adds it to an array of images to return
   */
  _resize: function(canvas, startWidth, startHeight){
    var targetWidth, targetHeight;
    var currentWidth = startWidth;
    var currentHeight = startHeight;

    var largestDimension = Math.max(startWidth, startHeight)
    // If the image has a dimension larger than maxDimension
    if (largestDimension > this.maxDimension){
      // Get the desired Dimensions
      // If the width is larger, calculate the height and use maxDimension for the width
      if (largestDimension == startWidth){
        targetWidth = this.maxDimension;
        targetHeight = startHeight * this.maxDimension / startWidth;
      } else { // Else, calculate the width and use maxDimension for the height
        targetWidth = startWidth * this.maxDimension / startHeight;
        targetHeight = this.maxDimension;
      }
      canvas = this._loopToTargetSize(canvas, targetWidth, targetHeight, startWidth, startHeight)
    }

    // Add the original image to the array of canvases
    var originalImage = canvas;
    canvases = [];
    canvases.push(originalImage);

    // If the user does not provide both resize width and height, set them based on aspect ratio. Otherwise, do not resize image
    if(this.resizeWidth == null && this.resizeHeight != null){
      this.resizeWidth = currentWidth * this.resizeHeight / currentHeight;
    }else if(this.resizeWidth != null && this.resizeHeight == null){
      this.resizeHeight = currentHeight * this.resizeWidth / currentWidth;
    }else if(this.resizeWidth == null && this.resizeHeight == null){
      this.resizeWidth = currentWidth;
      this.resizeHeight = currentHeight;
    }

    // Resize the image to maxScale * resize-height and width
    canvas = this._loopToTargetSize(canvas, this.maxScale*this.resizeWidth, this.maxScale* this.resizeHeight);
    var currentImage = canvas.toBlob(function(blob) {
        return(blob);
    });
    canvases.push(canvas);

    // Make all the scales using scaleStep and save each of those into an array
    var sizes = [];
    var range = this.maxScale - 1;
    var currentSize = this.maxScale;
    while (currentSize != 1){
      sizes.push(currentSize-this.scaleStep);
      currentSize = currentSize - this.scaleStep;
    }

    for (i = 0; i < sizes.length; i++) { 
      canvas = this._loopToTargetSize(canvas, sizes[i]*this.resizeWidth, sizes[i]* this.resizeHeight);
      canvases.push(canvas);
    }

    // Get the 10% base64 placeholder and return it to placeholder
    canvas = this._loopToTargetSize(canvas, Math.max(0.1*this.resizeWidth,8), Math.max(0.1* this.resizeHeight,8));
    this.placeholder = canvas.toDataURL();

    var promises = [];
    for (i = 0; i < canvases.length; i++) { 
      promises.push( new Promise(function(resolve, reject){
        canvases[i].toBlob(function(blob){
          resolve(blob);
        })
      }));
    }
    
    return Promise.all(promises).then(function(b){
      this._uploadMultiple(b, sizes)
      this.files = b;
    }.bind(this));

  }, // End resize blob

  _uploadMultiple: function (files, sizes) {
    var name = this.path;
    sizes = ['original'].concat(sizes)
    sizes.push('placeholder')
    name = name.substring(name.lastIndexOf('/')+1)
    for (i = 0; i < files.length; i++) {
      if (typeof sizes[i] === 'number'){
        this._uploadThis(files[i], name +'@'+sizes[i].toString()+'x');
      } else {
        this._uploadThis(files[i], name +"-"+sizes[i].toString());
      }
      
    }
  },

  _uploadThis: function(file, storagePath){
    return new Promise(function(resolve, reject){
      // Get a reference to the storage service, which is used to create references in your storage bucket.
      var storage = firebase.storage(firebase.app(this.appName));
      // Create a storage reference from our storage service.
      var storageRef = storage.ref();
      // Upload file and metadata to the object 'images/mountains.jpg'
      var uploadTask = storageRef.child(this.path.substring(0,this.path.lastIndexOf('/')) +'/'+storagePath).put(file);
      // Listen for state changes, errors, and completion of the upload.
      uploadTask.on(firebase.storage.TaskEvent.STATE_CHANGED, // or 'state_changed'
      function(snapshot) {
          // Get task progress, including the number of bytes uploaded and the total number of bytes to be uploaded
          this.progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
          //console.log('Upload is ' + progress + '% done');
          switch (snapshot.state) {
          case firebase.storage.TaskState.PAUSED: // or 'paused'
              //console.log('Upload is paused');
              break;
          case firebase.storage.TaskState.RUNNING: // or 'running'
              //console.log('Upload is running');
              break;
          }
      }.bind(this), function(error) {
        switch (error.code) {
            case 'storage/unauthorized':
                //console.log('Please adjust the storage rules in the Firebase console');
                reject('storage/unauthorized');
            break;
            case 'storage/canceled':
                //console.log('Oopps! You canceled the upload');
                reject('storage/canceled');
            break;
            case 'storage/unknown':
                //console.log('Unknown Error: '+ error.serverResponse);
                reject('storage/unknown');
            break;
        }
      }, function() {
        // Upload completed successfully, now we can get the download URL
        var downloadURL = uploadTask.snapshot.downloadURL;
        this.downloadUrl.push(downloadURL); 
        //console.log(this.downloadUrl);
        resolve(downloadURL);
      }.bind(this));
    }.bind(this)); 
  },


  _resizeCanvas: function(canvas, width, height){
    var canvas2 = document.createElement('canvas');
    var context2 = canvas2.getContext('2d');
    canvas2.width = width;
    canvas2.height = height;
    context2.drawImage(canvas, 0, 0, width, height);
    return canvas2;
  },

  _loopToTargetSize: function(canvas, targetWidth, targetHeight, currentWidth, currentHeight){
    var targetSizeReached = false
    // Reduce the image size to fit the maxDimension
    while (!targetSizeReached){
      // If currentHeight is more than double the targetHeight and the currentWidth is more than double the targetWidth, halve the image
      if (currentHeight > 1.25 * targetHeight && currentWidth > 1.25* targetWidth){
        currentWidth = 0.8 * currentWidth;
        currentHeight = 0.8 * currentHeight;
        canvas = this._resizeCanvas(canvas, currentWidth, currentHeight);
      } else { // Else Resize to maxDimension and set targetSizeReached to true
        canvas = this._resizeCanvas(canvas, targetWidth, targetHeight);
        targetSizeReached = true;
      }
    }
    return canvas;
  }
};
</script>